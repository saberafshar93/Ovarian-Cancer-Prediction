<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ovarian Tumor Prediction</title>
</head>
<body>
    <h1>Ovarian Tumor Prediction Tool</h1>
    <form id="predictionForm">
        <label for="patientID">Patient ID:</label>
        <input type="text" id="patientID" name="patientID" required><br><br>

        <label for="rowNumber">Row Number:</label>
        <input type="number" id="rowNumber" name="rowNumber" required><br><br>

        <label for="feature1">Feature 1:</label>
        <input type="number" id="feature1" name="feature1" step="0.01" required><br><br>

        <label for="feature2">Feature 2:</label>
        <input type="number" id="feature2" name="feature2" step="0.01" required><br><br>

        <label for="feature3">Feature 3:</label>
        <input type="number" id="feature3" name="feature3" step="0.01" required><br><br>

        <label for="feature4">Feature 4:</label>
        <input type="number" id="feature4" name="feature4" step="0.01" required><br><br>

        <label for="feature5">Feature 5:</label>
        <input type="number" id="feature5" name="feature5" step="0.01" required><br><br>

        <button type="button" onclick="makePredictions()">Predict</button>
    </form>

    <h2>Predictions:</h2>
    <ul id="predictions"></ul>

    <script>
        async function preprocessData(data) {
            // تبدیل تمام داده‌ها به عددی و مدیریت مقادیر گمشده
            const processedData = {...data};
            for (let key in processedData) {
                if (key !== 'Patient ID' && key !== 'RowNumber') { // نادیده گرفتن ستون‌های غیر عددی
                    if (typeof processedData[key] === 'string') {
                        processedData[key] = parseFloat(processedData[key]);
                    }
                    if (isNaN(processedData[key])) {
                        processedData[key] = 0;
                    }
                    // لگاریتم گرفتن از مقادیر مثبت
                    if (processedData[key] > 0) {
                        processedData[key] = Math.log10(processedData[key]);
                    }
                }
            }
            return processedData;
        }

        function predictLogisticRegression(patientData) {
            const features = Object.keys(patientData).filter(key => 
                key !== 'Patient ID' && key !== 'RowNumber'
            );
            
            // وزن‌های تصادفی برای هر ویژگی
            const weights = features.map(() => Math.random() * 2 - 1);
            const bias = -0.1;

            let sum = bias;
            features.forEach((feature, i) => {
                sum += patientData[feature] * weights[i];
            });

            const probability = 1 / (1 + Math.exp(-sum));
            return probability > 0.5 ? 'Non-benign Ovarian cancer (OC)' : 'Benign Ovarian Tumors (BOT)';
        }

        function predictDecisionTree(patientData) {
            let score = 0;
            const features = Object.keys(patientData).filter(key => 
                key !== 'Patient ID' && key !== 'RowNumber'
            );
            
            features.forEach(feature => {
                const value = patientData[feature];
                if (value > 1.5) score += 1;  // امتیازدهی ساده برای مقادیر بالا
            });

            return score > features.length/3 ? 'Non-benign Ovarian cancer (OC)' : 'Benign Ovarian Tumors (BOT)';
        }

        function predictRandomForest(patientData) {
            const features = Object.keys(patientData).filter(key => 
                key !== 'Patient ID' && key !== 'RowNumber'
            );
            
            let votes = 0;
            const numberOfTrees = 5;
            
            // شبیه‌سازی چندین درخت تصمیم
            for(let i = 0; i < numberOfTrees; i++) {
                let treeScore = 0;
                features.forEach(feature => {
                    const threshold = Math.random(); // آستانه تصادفی برای هر درخت
                    if (patientData[feature] > threshold) treeScore += 1;
                });
                if (treeScore > features.length/3) votes += 1;
            }

            return votes > numberOfTrees/2 ? 'Non-benign Ovarian cancer (OC)' : 'Benign Ovarian Tumors (BOT)';
        }

        function predictSVM(patientData) {
            const features = Object.keys(patientData).filter(key => 
                key !== 'Patient ID' && key !== 'RowNumber'
            );
            
            let decision = 0;
            features.forEach(feature => {
                decision += patientData[feature] * (Math.random() * 2 - 1); // وزن‌های تصادفی
            });

            return decision > 0 ? 'Non-benign Ovarian cancer (OC)' : 'Benign Ovarian Tumors (BOT)';
        }

        function predictNeuralNetwork(patientData) {
            const features = Object.keys(patientData).filter(key => 
                key !== 'Patient ID' && key !== 'RowNumber'
            );
            
            const inputValues = features.map(f => patientData[f]);
            
            // لایه مخفی با 3 نورون
            const hiddenLayer = Array(3).fill().map(() => {
                return math.sum(inputValues.map((value, i) => 
                    value * (Math.random() * 2 - 1)
                ));
            });
            
            // لایه خروجی
            const output = math.sum(hiddenLayer.map(h => 
                h * (Math.random() * 2 - 1)
            ));
            
            return output > 0 ? 'Non-benign Ovarian cancer (OC)' : 'Benign Ovarian Tumors (BOT)';
        }

        async function makePredictions() {
            const formData = new FormData(document.getElementById('predictionForm'));
            const patientData = {};
            formData.forEach((value, key) => {
                patientData[key] = value;
            });

            const processedData = await preprocessData(patientData);

            const predictions = [
                predictLogisticRegression(processedData),
                predictDecisionTree(processedData),
                predictRandomForest(processedData),
                predictSVM(processedData),
                predictNeuralNetwork(processedData)
            ];

            const predictionList = document.getElementById('predictions');
            predictionList.innerHTML = '';
            predictions.forEach(prediction => {
                const li = document.createElement('li');
                li.textContent = prediction;
                predictionList.appendChild(li);
            });
        }
    </script>
</body>
</html>
