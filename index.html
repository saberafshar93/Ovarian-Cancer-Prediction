<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ovarian Cancer Prediction App</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.js"></script>
    <style>
        /* [Previous CSS styles remain unchanged] */
    </style>
</head>
<body>
    <!-- [Previous HTML structure remains unchanged] -->

    <script>
        let currentPage = 0;
        let patientData = null;
        let modelPredictions = null;
        let trainingData = null;
        let trainingLabels = null;

        // Define the parameters that should skip log transformation
        const skipLogTransform = new Set([
            'Patient ID', 
            'RowNumber', 
            'Age', 
            'Menopausal',
            // Add other categorical or binary parameters here
        ]);

        // Define numerical parameters that should undergo standardization
        const numericalParameters = new Set([
            'Age',
            'CA125',
            'HE4',
            'Weight',
            'Height',
            'BMI',
            // Add all other numerical parameters here
        ]);

        async function preprocessData(data) {
            const processedData = {...data};
            
            // First pass: Convert strings to numbers and handle missing values
            for (let key in processedData) {
                if (key !== 'Patient ID' && key !== 'RowNumber') {
                    if (typeof processedData[key] === 'string') {
                        processedData[key] = parseFloat(processedData[key]);
                    }
                    if (isNaN(processedData[key])) {
                        processedData[key] = 0; // Default value for missing data
                    }
                }
            }

            // Second pass: Apply log transformation to appropriate parameters
            for (let key in processedData) {
                if (!skipLogTransform.has(key) && numericalParameters.has(key) && processedData[key] > 0) {
                    processedData[key] = Math.log10(processedData[key]);
                }
            }

            // Third pass: Standardization (z-score normalization)
            // This would ideally use pre-calculated means and standard deviations from the training data
            if (trainingData && trainingData.length > 0) {
                for (let key in processedData) {
                    if (numericalParameters.has(key)) {
                        const values = trainingData.map(row => parseFloat(row[key])).filter(val => !isNaN(val));
                        const mean = values.reduce((a, b) => a + b, 0) / values.length;
                        const std = Math.sqrt(values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length);
                        if (std !== 0) {
                            processedData[key] = (processedData[key] - mean) / std;
                        }
                    }
                }
            }

            return processedData;
        }

        function predictLogisticRegression(patientData) {
            const features = Object.keys(patientData).filter(key => 
                key !== 'Patient ID' && key !== 'RowNumber'
            );
            
            // Initialize weights for each feature
            const weights = features.map(() => Math.random() * 2 - 1);
            const bias = -0.1;

            let sum = bias;
            features.forEach((feature, i) => {
                const value = patientData[feature] || 0;
                sum += value * weights[i];
            });

            const probability = 1 / (1 + Math.exp(-sum));
            return probability > 0.5 ? 'Non-benign Ovarian cancer (OC)' : 'Benign Ovarian Tumors (BOT)';
        }

        function predictDecisionTree(patientData) {
            const features = Object.keys(patientData).filter(key => 
                key !== 'Patient ID' && key !== 'RowNumber'
            );
            
            let score = 0;
            const thresholds = {};
            
            // Set different thresholds for different feature types
            features.forEach(feature => {
                if (numericalParameters.has(feature)) {
                    thresholds[feature] = 0.5; // Standardized threshold
                } else {
                    thresholds[feature] = 0; // Binary/categorical threshold
                }
            });

            features.forEach(feature => {
                const value = patientData[feature] || 0;
                if (value > thresholds[feature]) score += 1;
            });

            return score > features.length/2 ? 'Non-benign Ovarian cancer (OC)' : 'Benign Ovarian Tumors (BOT)';
        }

        function predictRandomForest(patientData) {
            const features = Object.keys(patientData).filter(key => 
                key !== 'Patient ID' && key !== 'RowNumber'
            );
            
            let votes = 0;
            const numberOfTrees = 10; // Increased number of trees
            
            for(let i = 0; i < numberOfTrees; i++) {
                let treeScore = 0;
                const selectedFeatures = features
                    .sort(() => Math.random() - 0.5)
                    .slice(0, Math.floor(features.length * 0.7)); // Random feature selection
                
                selectedFeatures.forEach(feature => {
                    const value = patientData[feature] || 0;
                    const threshold = numericalParameters.has(feature) ? 
                        Math.random() * 2 - 1 : // For numerical features
                        0; // For categorical features
                    
                    if (value > threshold) treeScore += 1;
                });
                
                if (treeScore > selectedFeatures.length/2) votes += 1;
            }

            return votes > numberOfTrees/2 ? 'Non-benign Ovarian cancer (OC)' : 'Benign Ovarian Tumors (BOT)';
        }

        function predictSVM(patientData) {
            const features = Object.keys(patientData).filter(key => 
                key !== 'Patient ID' && key !== 'RowNumber'
            );
            
            let decision = 0;
            const weights = {};
            
            // Initialize weights based on feature type
            features.forEach(feature => {
                weights[feature] = numericalParameters.has(feature) ? 
                    Math.random() * 2 - 1 : // Numerical features
                    (Math.random() > 0.5 ? 1 : -1); // Categorical features
            });

            features.forEach(feature => {
                const value = patientData[feature] || 0;
                decision += value * weights[feature];
            });

            return decision > 0 ? 'Non-benign Ovarian cancer (OC)' : 'Benign Ovarian Tumors (BOT)';
        }

        function predictNeuralNetwork(patientData) {
            const features = Object.keys(patientData).filter(key => 
                key !== 'Patient ID' && key !== 'RowNumber'
            );
            
            const inputValues = features.map(f => patientData[f] || 0);
            const hiddenLayerSize = Math.floor(features.length * 0.7); // Dynamic hidden layer size
            
            // First hidden layer
            const hiddenLayer1 = Array(hiddenLayerSize).fill().map(() => {
                return math.tanh(math.sum(inputValues.map((value, i) => 
                    value * (Math.random() * 2 - 1)
                )));
            });
            
            // Second hidden layer
            const hiddenLayer2 = Array(Math.floor(hiddenLayerSize/2)).fill().map(() => {
                return math.tanh(math.sum(hiddenLayer1.map(h => 
                    h * (Math.random() * 2 - 1)
                )));
            });
            
            // Output layer
            const output = math.tanh(math.sum(hiddenLayer2.map(h => 
                h * (Math.random() * 2 - 1)
            )));
            
            return output > 0 ? 'Non-benign Ovarian cancer (OC)' : 'Benign Ovarian Tumors (BOT)';
        }

        // [Rest of the code remains unchanged]

    </script>
</body>
</html>